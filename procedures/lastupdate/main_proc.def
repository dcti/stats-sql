use stats
go

\set procedure=p_lastupdate

if (object_id("$procedure") is not null)
begin
        print "Dropping procedure $procedure"
        drop procedure $procedure
end
go

\echo "Creating procedure $procedure"
create procedure $procedure
(	@section char(1) = null,	/* What section to look at (i.e. e for email, t for team) */
	@contest varchar(10) = null,	/* Contest that we want the lastupdateing on */
	@timeframe char(1) = null	/* Timeframe we want to look at (overall v. yesterday) */
)
as
begin
	declare @procname	varchar(30)	/* Name of the procedure to run */

	/* Error checking */

	/* Make sure all the parameters were specified */
	if ( (@section = null) or (@contest = null) or (@timeframe = null) )
	begin
		raiserror 99999 "Not enough parameters"
		print "usage:"
		print "	lastupdate section, contest, timeframe"
		print "where:"
		print "	section is email or team (i.e. e or t)"
		print "	contest is contest to check lastupdate on"
		print "	timeframe is the lastupdateing to check (i.e. o for overall or y for yesterday)"
		return -5
	end

	/* Process @section */
	select @section = lower(@section)
	if not @section in ("e", "t")
	begin
		raiserror 99999 "Invalid section '%1!' specified, must be 'e' or 't'", @section
		return -5
	end
	
	/* Process @timeframe  */
	select @timeframe = lower(@timeframe)
	if not @timeframe in ("", "o", "y")
	begin
		raiserror 99999 "Invalid timeframe '%1!' specified, must be 'o' or 'y'", @timeframe
		return -5
	end

	/* Build the procedure name */
	select @procname = "p_lastupdate_" + @contest + "_" + @section + "_" + @timeframe 
	
	/* See if the silly procedure exists */
	if (object_id("@procname") is NULL)
	begin
		raiserror 99999 "Procedure '%1!' does not exist!", @procname
		return -1
	end

	exec @procname
	return 
end
go

grant execute on p_lastupdate to public
go

